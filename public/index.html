<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>Stealth WS Tunnel</title>
</head>
<body>
<h1>Stealth Tunnel</h1>

<input id="path" value="/apx/hello" />
<button id="go" disabled>Fetch</button>

<iframe
  id="frame"
  style="width:100%; height:70vh; border:1px solid #444;"
  sandbox="allow-scripts allow-forms">
</iframe>

<script>
let ws;
let aesKey;
const pending = new Map();
const enc = new TextEncoder();
const dec = new TextDecoder();

/* ---------- base64 helpers (binary safe) ---------- */
const b64 = buf =>
  btoa(String.fromCharCode(...new Uint8Array(buf)));
const fromB64 = str =>
  Uint8Array.from(atob(str), c => c.charCodeAt(0));

/* ---------- WS + crypto init ---------- */
async function initWS() {
  ws = new WebSocket("wss://asd-ywj6.onrender.com/ws");
  ws.binaryType = "arraybuffer";

  await new Promise((res, rej) => {
    ws.onopen = res;
    ws.onerror = rej;
  });

  console.log("[WS] connected");

  ws.onclose = () => location.reload();
  ws.onerror = () => ws.close();

  // fetch RSA public key
  const pem = await fetch("https://asd-ywj6.onrender.com/public.pem").then(r => r.text());
  const keyData = pem.replace(/-----.*?-----/g, "").replace(/\s+/g, "");

  const pubKey = await crypto.subtle.importKey(
    "spki",
    fromB64(keyData),
    { name: "RSA-OAEP", hash: "SHA-256" },
    false,
    ["encrypt"]
  );

  aesKey = crypto.getRandomValues(new Uint8Array(32));
  const encryptedKey = await crypto.subtle.encrypt(
    "RSA-OAEP",
    pubKey,
    aesKey
  );

  ws.send(JSON.stringify({
    type: "init",
    encryptedKeyBase64: b64(encryptedKey)
  }));

  ws.onmessage = async ev => {
    const msg = JSON.parse(ev.data);
    if (msg.type !== "data") return;

    const iv = fromB64(msg.ivBase64);
    const encData = fromB64(msg.payloadBase64);

    const key = await crypto.subtle.importKey(
      "raw",
      aesKey,
      "AES-GCM",
      false,
      ["decrypt"]
    );

    const plain = await crypto.subtle.decrypt(
      { name: "AES-GCM", iv },
      key,
      encData
    );

    const payload = JSON.parse(dec.decode(plain));
    pending.get(msg.id)?.(payload);
    pending.delete(msg.id);
  };
}

/* ---------- Send encrypted to WS ---------- */
async function sendEncrypted(id, payload) {
  const iv = crypto.getRandomValues(new Uint8Array(12));
  const key = await crypto.subtle.importKey(
    "raw",
    aesKey,
    "AES-GCM",
    false,
    ["encrypt"]
  );

  const encData = await crypto.subtle.encrypt(
    { name: "AES-GCM", iv },
    key,
    enc.encode(JSON.stringify(payload))
  );

  ws.send(JSON.stringify({
    type: "data",
    id,
    ivBase64: b64(iv),
    payloadBase64: b64(encData)
  }));
}

/* ---------- SW messaging ---------- */
function initProxyMessaging() {
  navigator.serviceWorker.addEventListener("message", evt => {
    if (evt.data?.type !== "proxy-fetch") return;

    const { id, req } = evt.data;

    pending.set(id, res => {
      if (navigator.serviceWorker.controller) {
        navigator.serviceWorker.controller.postMessage({ id, res });
      }
    });

    const url = new URL(req.url);

    // filter headers (important)
    const cleanHeaders = {};
    for (const [k, v] of Object.entries(req.headers || {})) {
      if (!["host", "origin", "referer", "content-length"].includes(k.toLowerCase())) {
        cleanHeaders[k] = v;
      }
    }

    sendEncrypted(id, {
      method: req.method,
      url: url.pathname, // base62-safe path
      headers: cleanHeaders,
      body: req.body
    });
  });
}

/* ---------- Init ---------- */
(async () => {
  await navigator.serviceWorker.register("/sw.js");
  await navigator.serviceWorker.ready;

  if (!navigator.serviceWorker.controller) {
    await new Promise(res =>
      navigator.serviceWorker.addEventListener("controllerchange", res, { once: true })
    );
  }

  initProxyMessaging();
  await initWS();

  console.log("[Page] ready");
  document.getElementById("go").disabled = false;
})();

/* ---------- Fetch button ---------- */
document.getElementById("go").onclick = async () => {
  const path = document.getElementById("path").value.trim();
  const frame = document.getElementById("frame");

  if (!path.startsWith("/apx/")) {
    alert("Only /apx/ paths allowed");
    return;
  }

  const res = await fetch(path); // intercepted by SW
  const html = await res.text();

  const blob = new Blob([html], { type: "text/html" });
  frame.src = URL.createObjectURL(blob);
};
</script>
</body>
</html>
